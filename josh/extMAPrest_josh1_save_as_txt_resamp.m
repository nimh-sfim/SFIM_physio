%Resample the CareTaker's pulse and vitals CSV data into
%even sampling grids using Radial Base Functions, and save these outputs as
%.tsv files. Also, synchronize the CareTaker pulse and vitals data wrt one another. 
%Variable naming convention: bp is Biopac (originally ACQ), AND ct is caretaker (originally CSV)

clear

% dependencies
addpath(genpath('/Volumes/SFIM/akin/bin/NIfTI_20140122'))
addpath(genpath('/Volumes/SFIM/akin/bin/load_acq'))
addpath(genpath('/Volumes/SFIM/akin/bin/burak/'))

% Two subjects don't have blood pressure data:
% sub17 only has 80 timepoints. <-- .csv files only have ~20 rows of data
% sub29 doesn't have bp_files. There's a README that explains because of nails

% For CareTaker, 31.25 ms is the period between samples
% AKA, 32 Hz is the sampling rate!

%subjects = ["34"];
subjects = ["10","11","12","13","14","15","16","18","19","20","21","22","23","24","25","26","27","28","30","31","32","33","34"];

for ii = 1:length(subjects)
    sbjid = subjects(ii);

    % Load caretaker (csv data)
    dir1 = strjoin(["/Volumes/SFIM_physio/data/bp" sbjid "/physio/"],'');
    fileList_bp = fullfile(dir1, 'Log*/', 'Log*_pulse*.csv');
    theFiles_bp = dir(fileList_bp);
    dir2 = theFiles_bp.folder;
    c = readtable(strjoin([dir2, "/", theFiles_bp.name],''));
    
    %% Save intermediate step with the extracted EQUAL SAMPLING
    % we're attempting to resample array from 
    % an uneven grid to an even re-sampled grid in MATLAB
    
    ct_timings=c(:,2).Time;
    ct_timings_norm=ct_timings-ct_timings(1);
    ct_timings_norm_sec = seconds(ct_timings_norm);
    
    %To convert from table to array requires all data to be same type
    %From the 4-column table generated from the excel sheet generated by
    %CareTaker ('Log*_pulse*.csv'), save the Time as normalized seconds
    %(double) and value, s.t. it's a 2 column output
    %columns: Date, Time, Value, Counter... --> Time and Value are the only ones of interest
    
    log_pulse_csv = [ct_timings_norm_sec, table2array(c(:,3))];
    % First column is seconds, second column is the direct pressure recorded by
    % the finger cuff. Sampling should be 32 Hz; Caretaker has 31.25 ms in between samples (period).

    %% 
    final_time_pulse = log_pulse_csv(end,1);
    dt_pulse = 31.25;
    n_pulse = final_time_pulse * dt_pulse + 1;
    t3 = [0: 1/dt_pulse: n_pulse/dt_pulse]';

    % Save the data as a .tsv file, with column one being time and column 2
    % being the Value of direct pressure cuff recording. 
    dir4 = strjoin(["/Volumes/SFIM_physio/physio/physio_results/sub" sbjid "/"],''); 
    cd(dir4)
    
    log_pulse_resampled = array2table([t3, log_pulse_csv(1:length(t3), 2)]);
    log_pulse_resampled.Properties.VariableNames = c.Properties.VariableNames(2:3);
    filename2save = strjoin(["sub" sbjid "_pulse_csv_resampled.tsv"],'');
    writetable(log_pulse_resampled, filename2save,'filetype','text', 'delimiter','\t')

    %% Load the vitals CSV file
    fileList_vitals = fullfile(dir2, 'Log*_vitals_*.csv'); %added underscore to differentiate from vitalsavg
    theFiles_vitals = dir(fileList_vitals);
    log_vitals_csv=readtable(strjoin([dir2, "/", theFiles_vitals.name],''));
    tarray=table2array(log_vitals_csv(:,2));         % in HH:MM:SS.mS format
    
    % Check to make sure that the column names are consistent with my expectations
    expected_col_names = ["Date","Time","Systolic_mmHg_","Diastolic_mmHg_","MAP_mmHg_",...
        "HeartRate_bpm_","Respiration_Bpm_","AS","SQE","TimeStamp_mS_"];
    for jj = 1:length(log_vitals_csv.Properties.VariableNames)
        if strcmp(log_vitals_csv.Properties.VariableNames(jj),expected_col_names(jj)) == 0
            disp(['WARNING: COLUMN NAMES OF TABLE DO NOT MEET MY EXPECTATIONS, index: ', num2str(jj), '.'])
        end
    end
    
    %Convert second column to seconds (like was done for log_pulse_csv)
    %While doing so, synchronize the vitals CSV timings wrt the Pulse CSV timings
    log_vitals_csv_timings=log_vitals_csv(:,2).Time;
    log_vitals_csv_timings_norm=log_vitals_csv_timings-ct_timings(1);
    log_vitals_csv_sec = seconds(log_vitals_csv_timings_norm);
    
    %Save as table because it has headings, excluding the first column (Date) 
    % and non-blood pressure related data.
    log_vitals_csv_mat = [array2table(log_vitals_csv_sec), log_vitals_csv(:,3:5)];
    
    %% Now let's resample the log_vitals_csv_mat variable from uneven sampling grid
    % to even upsampled grid
    % Radial basis functions to do this. Convolves with a kernel and uses a
    % neural network. Save the upsampled, evengrid data as a .tsv
    
    log_vitals_csv_mat_arr = table2array(log_vitals_csv_mat);
    T = size(log_vitals_csv_mat_arr,1);             %number of samples in original data to be resampled
    t_vitals = log_vitals_csv_mat_arr(:,1);         %array of indices in original data to be resampled    
    final_time = log_vitals_csv_mat_arr(end,1);     %unit: seconds
    start_time = log_vitals_csv_mat_arr(1,1);     %unit: seconds

    % Let's solve for how many data points there will be in new upsampled data
    % spacing between points = 1/fsamp = (x2-x1)/(n-1)
    % 1/fsamp = (final_time - 0) / (n-1)
    % (n-1)/fsamp = final_time
    % (n-1) = final_time * fsamp
    % n = final_time * fsamp + 1
    fsamp = 10;
    n = final_time * fsamp + 1;
    t2 = [start_time: 1/fsamp: n/fsamp];     %10 samples per second
    
    %% Radial Base Functions
    [t_uni_val, t_uni_idx] = unique(t_vitals);      %t_uni_val are the coordinates of nodes
    f_sys = log_vitals_csv_mat_arr(t_uni_idx,2);    %values of function at the nodes
    f_dia = log_vitals_csv_mat_arr(t_uni_idx,3);    %values of function at the nodes
    f_map = log_vitals_csv_mat_arr(t_uni_idx,4);    %values of function at the nodes
    
    smooth_factor = 1;
    rbf_sys = rbfcreate(t_uni_val',f_sys','RBFFunction','multiquadric','RBFSmooth',smooth_factor); 
    rbf_dia = rbfcreate(t_uni_val',f_dia','RBFFunction','multiquadric','RBFSmooth',smooth_factor); 
    rbf_map = rbfcreate(t_uni_val',f_map','RBFFunction','multiquadric','RBFSmooth',smooth_factor); 
        
    % Calculate interpolated values
    fi_sys = rbfinterp(t2, rbf_sys);
    fi_dia = rbfinterp(t2, rbf_dia);
    fi_map = rbfinterp(t2, rbf_map);

    figure(ii)
    tiledlayout(2,1)
    nexttile
    plot(t2, fi_sys, 'DisplayName', 'SYS'); hold on;
    plot(t2, fi_dia, 'DisplayName', 'DIA'); hold on;
    plot(t2, fi_map, 'DisplayName', 'MAP'); hold on;
    title(strjoin(["sub" sbjid],''))
    xlabel(strjoin(["number of tmpts: " length(t2)],''))
    legend()

    nexttile
    plot(t2(1:10:end), fi_sys(1:10:end),'DisplayName','SYS Smoothened');
    hold on; 
    plot(t_uni_val,log_vitals_csv_mat_arr(t_uni_idx,2),'DisplayName','SYS Raw')
    legend()
    saveas(figure(ii), strjoin(["sub" sbjid "_blood_pressure_plots_and_smo-v-raw.jpg"],''))

    % Save the interpolated data (with smoothing to remove the integer noise)
    % as a .tsv file, with column one being time and column 2-4 being systolic,
    % diastolic, and mean arterial blood pressure. 
    
    vitals_csv_upsampled = array2table([t2; fi_sys; fi_dia; fi_map]');
    vitals_csv_upsampled.Properties.VariableNames = log_vitals_csv.Properties.VariableNames(2:5);
    
    filename2save = strjoin(["sub" sbjid "_vitals_csv_upsampled.tsv"],'');
    
    writetable(vitals_csv_upsampled, filename2save,'filetype','text', 'delimiter','\t')

end



%% Previous approaches below... 

% For my own sanity, let's make sure that the new grid indeed increases by 1/fsamp seconds
% if not(t2(5) - t2(4) == 1/fsamp)
%     disp('WARNING: THE NEW SAMPLING GRID IS NOT CORRECT')
% end
% sprintf('%f', t2(5) - t2(4))
% sprintf('%f', 1/fsamp)

% if sbjid == "12" | sbjid == "13"
%     fsamp = 1000;   %sampling rate for BIOPAC (ACQ data)
% else
%     fsamp = 500;
% end

% Nope, not doing this anymore... 
% t2 = linspace(0,final_time, n);      %indices for the soon-to-be resampled data in seconds

% Not using griddedInterpolant anymore
% For griddedInterpolant, sample points must be unique. Because t contains 
% samples that have duplicates, remove duplicates using the unique function
% [t_uni_val, t_uni_idx] = unique(t); 
% F = griddedInterpolant(t_uni_val,x(t_uni_idx,1),'linear');
% plot(F.Values)
% upsamp_data = F(t2);
% plot(upsamp_data)

% Another approach that I kind of gave up on... 
% % Define training set
% x = linspace(0,10,10);
% y = sin(x);
% plot(x,y);
% 
% % maybe unnecessary? Defines the transfer function and plots it
% a = radbas(y)
% plot(x,a)
% 
% % Does the convolving with the kernel -- the actual stuff of note
% eg = 0.02; % sum-squared error goal
% sc = 1;    % spread constant
% net = newrb(x,y,eg,sc);
% 
% % Plot the training set (x,y) and the new data (x, net(x))
% plot(x,y, 'x'); hold on; plot(x, net(x))
% title('Does it look like it did the thingy?')
% 
% % Totally another thing?
% P = [1 2 3];
% T = [2.0 4.1 5.9];
% net = newrb(P,T);
% P = 1.5;
% Y = sim(net,P)


% Below is most similar to what we did with python previously last Spring-ish



%% QUESTION: --> this was answered. first row of vitals starts later than 
% first row of pulse, because was unstable at beginning and only begins 
% converting cuff values to blood pressure values after becoming stable 
% (unstable indicated by the MANY 0's being present at the beginning of 
% the pulse spreadsheet)
%
% In first column, for every duplicated (multiple times) index, there are 
% corresponding unique values. Thus fails classification of being a function 
% and would thereby make it difficult to interpolate???

% Also, trying to understand length discrepencies: 
% log_pulse_csv(end,1) = 5983 <-- direct cuff pressure recording
% log_vitals_csv_sec(end) <-- 5900.1
% Why does the pulse and vitals .csv spreadsheets have different
% lengths? Start time different? End time different?
% Since Caretaker has 32 samples per second, I'll do:
% 31.25 ms is the period between samples
% 32 Hz is the sampling rate!
% final_time_pulse = log_pulse_csv(end,1);
% fsamp_pulse = 32;
% n_pulse = final_time_pulse * fsamp_pulse + 1;
% t3 = [0: 1/fsamp_pulse: n_pulse/fsamp_pulse];
% Does it matter (or more importantly, does it make sense that) the
% ending times don't match
% t2(end) = 5900.2 <-- the derived blood pressure values
% t3(end) = 5983 <-- the timings for the direct cuff pressure recording